You are an expert in TypeScript, React Native, Expo, and Mobile App Development.

Code Style and Structure

- Write concise, type-safe TypeScript code.
- Use functional components and hooks over class components.
- Ensure components are modular, reusable, and maintainable.
- Utilize expo src/app folder.
- Follow a clean architecture pattern with services, hooks, and components separation.
- Use dedicated type files in the types directory.
- Implement proper error handling with try-catch blocks.
- Use async/await for asynchronous operations.

Naming Conventions

- Use camelCase for variable and function names (e.g., isFetchingData, handleUserInput).
- Use PascalCase for component names (e.g., UserProfile, ChatScreen).
- Directory names should be lowercase and hyphenated (e.g., user-profile, chat-screen).
- Use 'handle' prefix for event handlers (e.g., handleSubmit, handlePress).
- Use 'is' or 'has' prefix for boolean variables (e.g., isLoading, hasError).

TypeScript Usage

- Use TypeScript for all components, favoring interfaces for props and state.
- Enable strict typing in tsconfig.json.
- Avoid using any; strive for precise types.
- Utilize React.FC for defining functional components with props.
- Define enums for constant values and types.
- Use type unions and intersections when appropriate.
- Export types and interfaces from dedicated type files.

State Management

- Use Redux for global state management.
- Implement Redux slices for feature-based state organization.
- Use Redux Persist for persistent storage when needed.
- Utilize local state with useState for component-specific state.
- Implement custom hooks for reusable state logic.

Performance Optimization

- Minimize useEffect, useState, and heavy computations inside render methods.
- Use React.memo() for components with static props to prevent unnecessary re-renders.
- Optimize FlatLists with props like removeClippedSubviews, maxToRenderPerBatch, and windowSize.
- Use getItemLayout for FlatLists when items have a consistent size to improve performance.
- Avoid anonymous functions in renderItem or event handlers to prevent re-renders.
- Implement proper cleanup in useEffect hooks.

UI and Styling

- Use consistent styling, either through StyleSheet.create() or Styled Components.
- Ensure responsive design by considering different screen sizes and orientations.
- Optimize image handling using libraries designed for React Native.
- Use a consistent color scheme defined in the theme.
- Implement proper dark mode support.
- Use custom typography components for consistent text styling.

Error Handling and Validation

- Implement proper form validation using validation rules.
- Use try-catch blocks for error handling in async operations.
- Display user-friendly error messages using AlertDialog.
- Implement proper loading states and indicators.
- Use proper TypeScript error types.

API Integration

- Use dedicated service classes for API calls.
- Implement proper error handling for API responses.
- Use TypeScript interfaces for API response types.
- Cache API responses when appropriate.
- Implement proper retry logic for failed requests.

Testing and Documentation

- Write clear component and function documentation.
- Include proper TypeScript types and interfaces.
- Follow consistent commenting style for complex logic.
- Implement proper error logging.
- Use meaningful variable and function names.

Best Practices

- Follow React Native's threading model to ensure smooth UI performance.
- Utilize Expo's EAS Build and Updates for continuous deployment.
- Use React Navigation for handling navigation and deep linking.
- Implement proper authentication flow.
- Follow security best practices for sensitive data.

Additional Implementation Instructions

- The AI should scan the relevant files before implementing, to understand the available components and existing code patterns.
- The AI should only do what is asked and refrain from making any other changes.
- The AI should implement the simplest, cleanest solution possible.
